Title: 2016
Level: 1
myCode: ```
function solution(a, b) {
    var answer = '';
    var countOfDay = 0;

    switch (a) {
        case 1: countOfDay = b; break;
        case 2: countOfDay = b+31; break;
        case 3: countOfDay = b+31+29; break;
        case 4: countOfDay = b+31+29+31; break;
        case 5: countOfDay = b+31+29+31+30; break;
        case 6: countOfDay = b+31+29+31+30+31; break;
        case 7: countOfDay = b+31+29+31+30+31+30; break;
        case 8: countOfDay = b+31+29+31+30+31+30+31; break;
        case 9: countOfDay = b+31+29+31+30+31+30+31+31; break;
        case 10: countOfDay = b+31+29+31+30+31+30+31+31+30; break;
        case 11: countOfDay = b+31+29+31+30+31+30+31+31+30+31; break;
        case 12: countOfDay = b+31+29+31+30+31+30+31+31+30+31+30; break;
    }

    var dayCnt = countOfDay % 7;

    switch (dayCnt) {
        case 0: answer = "THU"; break;
        case 1: answer = "FRI"; break;
        case 2: answer = "SAT"; break;
        case 3: answer = "SUN"; break;
        case 4: answer = "MON"; break;
        case 5: answer = "TUE"; break;
        case 6: answer = "WED"; break;
    }

    return answer;
}

```

bestCode: ```
function getDayName(a,b){
  var date = new Date(2016, (a - 1), b);
    return date.toString().slice(0, 3).toUpperCase();
}
```

lesson: 
* 으 아니 세상에 내가 40줄 써서 푼 문제를 다른 사람들은 두 줄 만에 해결하다니ㄷㄷ
* javascript 기본 기능에 대해서 공부를 많이 해야겠다.
* Date라는 기본 객체가 있구나.
* 그런데 월 부분에 왜 -1을 하지? 이 객체는 기본적으로 배열 형태이기 때문에 0부터 인덱스가 시작함. 즉, 12월 날짜를 생성하고 싶으면 Month[11]의 값을 꺼내와야 하니 a-1을 해줘야 한다.

 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 Title: 가운데 글자 가져오기
 Level: 1
 myCode: ```
 function solution(s) {
    var answer = '';
    var sArray = Array.from(s);
    var sLength = sArray.length;
    if (sLength % 2 == 1) {
        let index = parseInt(sLength/2);
        answer = sArray[index];
    } else {
        let index = sLength / 2;
        answer = s.slice(index-1,index+1);
    }
    
    return answer;
}
```
 bestCode:
```
function solution(s) {
    return s.substr(Math.ceil(s.length / 2) - 1, s.length % 2 === 0 ? 2 : 1);
}
```

lesson:
* 역시 Javascript의 기본 객체와 메서드에 대해서 잘 알고 있어야겠다는 생각이 든다.
* Math.ceil: 소수점 이하 버림
* 조건문?x:y를 정말 멋들어지게 쓰네.. 그리고 이게 인자값으로도 들어갈 수 있군.
* 아직 잘 쓰지도 못하면서 코드가 길어지는 것에 두려움을 갖지 말아야겠다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Title: 같은 숫자는 싫어
Level: 1
myCode:```
function solution(arr)
{
    var answer = [arr[0]];

    function dupTest(a,b) {
        if (a !== b) {
            answer.push(b);
        }
        return b;
    }
    
    arr.reduce(dupTest);
    
    return answer;
}
```
bestCode:
```
function solution(arr)
{
    return arr.filter((val,index) => val != arr[index+1]);
}
```

lessons:
* 배열에 대한 기본 메서드가 정말 다양하고, 내가 안다고 생각했는데 잘 모른다는 것을 분명히 깨달음.
* reduce를 쓴 이유는 배열 내의 두 요소를 차례대로 연산하기 때문이엇음.
* 그런데 다른 사람이 짠 코드를 보니까 filter 내의 함수 성질을 잘 알았으면 이렇게 해볼 수 있을 것 같음.
 궁금한 게, array에는 기본으로 val와 index가 뭔지 알아듣나? 그런 것 같음.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Title: 나누어 떨어지는 숫자 배열
Level: 1
myCode:```
function solution(arr, divisor) {
    var answer = [];
    function sorting (a,b) {
        if (a>b) return 1;
        else return -1;
    }
    
    answer = arr.filter(el => el % divisor === 0);
    
    if (answer.length > 0) answer.sort(sorting);
    else answer.push(-1);

    
    return answer;
}
```
bestCode:
```
function solution(arr, divisor) {
    var answer = [];
    arr.map((o) => {
        o % divisor === 0 && answer.push(o);
    })
    return answer.length ? answer.sort((a, b) => a - b) : [-1];

}
```

lessons:
* 나는 if 조건절에 배열만 넣으면, 그 배열이 값을 갖고 있으면 true, 아니면 false가 돼서 else절에 전달인 줄 알았는데 빈 배열도 true라고 인식하는 것 같다.
  이것 때문에 다 풀어놓고 개고생했음.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Title: 두 정수 사이의 합
Level: 1
myCode:```
function solution(a, b) {
    var answer = 0;
    
    let min = Math.min(a,b);
    let max = Math.max(a,b);

    for (min; min <= max; min ++) answer += min;     
    return answer;
}
```
bestCode:
```
function adder(a, b, s = 0){
  for (var i = Math.min(a, b); i <= Math.max(a, b); i++) s += i;
  return s;
}

```

lessons:
* 굳이 min, max를 별도 변수로 지정할 필요가 없었다는 생각이 듦.
* 이것도 약간의 고난이 있기는 했지만 잘 돌아감.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Title: 문자열 내 마음대로 정렬하기
Level: 1
myCode:```
function solution(strings, n) {
    var answer = [];

    function sorting(a,b) {
        if(a.charAt(n) > b.charAt(n)) return 1;
        else if(a.charAt(n) == b.charAt(n)) {
            if (a>b) return 1;
            else return -1;
        }
        else return -1;        
    }

    answer = strings.sort(sorting);
    return answer;
}
```
bestCode:
```
function solution(strings, n) {
    return strings.sort((s1, s2) => s1[n] === s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n]));
}
```

lessons:
* 이제 될 것 같은데! 다 한 것 같은데! 라는 생각이 들 때, 내가 쌓아 놓은 로직에 갇혀서 다른 방향을 찾아내지 못한다는 생각이 든다.
* 그래도 테스트가 성공 뜰 때의 쾌감은 정말 좋네. 수영이랑 같이 꾸준히 하면 여러모로 도움이 많이 될 것 같다.
* 코드를 예쁘게 쓰는 게 아니라 돌아가게 하는데 집중하고, 공식 문서에서 제시하는 문자열/자료구조 처리를 꼼꼼하게 살펴봐야겠다.
* 가장 큰 전제(선택한 인덱스의 문자로 정렬)는 쉽게 만들었는데, 그 뒤에 사전식 정렬을 구현하는 게 어려웠다.
* 문자열에도 비교부호가 먹힌다. alphabetic order에서 뒤에 있는 애가 더 큰 것. 이걸 이용해서 비교하고자 하는 인덱스의 문자가 같을 때, 사전식으로 정렬할 수 있었다. myCode의 else if 절.